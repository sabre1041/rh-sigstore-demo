# rh-sigstore

The contents of this repository contains a _highly opinionated_ self hosted deployment of [Sigstore](https://www.sigstore.dev) within an OpenShift Container Platform environment.

## Overview

The following components are part of this architecture

* sigstore
  * CTLog
  * Fulcio
  * Rekor
  * Trillian
  * TUF
* Keycloak (Red Hat SSO)

## Prerequisites

The following must be in place to support the deployment of the assets contained within this repository:

1. Software
    1. [OpenShift CLI](https://docs.openshift.com/container-platform/4.11/cli_reference/openshift_cli/getting-started-cli.html#cli-getting-started)
    2. [Helm](https://helm.sh)
    3. [jq](https://stedolan.github.io/jq)
    4. [cosign](https://docs.sigstore.dev/cosign/overview)
    5. [envsubst](https://www.gnu.org/software/gettext/manual/html_node/envsubst-Invocation.html)
2. OpenShift Container Platform with `cluster-admin` rights
3. IngressController configured with a certificate signed by a publicly trusted CA
4. Persistent Storage
5. An image available in a container registry and the ability to publish additional tags


## Deployment

Ensure that you are authenticated to the OpenShift cluster with the OpenShift CLI with `cluster-admin` privileges and execute the following command:

```shell
./setup.sh
```

Pods will fluculate in varying states as the infrastructure is established. Once complete, pods will be in the completed (from Jobs), running and ready in the following namespaces:

* ctlog-system
* fulcio-system
* keycloak-system
* rekor-system
* trillian-system
* tuf-system

The exposed URL's will be displayed at the end of the setup script.

## Signing and Verifying an Image

With the Sigstore architecture deployed and running, it can be used to sign and verify an image. 

First, set `COSIGN_EXPERIMENTAL=1` to enable keyless signing

```shell
export COSIGN_EXPERIMENTAL=1
```

### Initialize TUF

Next, cosign must be initialized with the TUF roots using the `cosign initialize` command

```shell
cosign initialize --mirror=https://$(oc get routes -n tuf-system -o jsonpath='{.items[0].spec.host }') --root=https://$(oc get routes -n tuf-system -o jsonpath='{.items[0].spec.host }')/root.json
```

### Sign an Image

With cosign now initialized, images can be signed using the established architecture.

Set the variable `IMAGE` with the location of the desired image to sign

```shell
export IMAGE=<image>
```

Now sign the image by specifiying the location of Fulcio, Rekor, Keycloak OIDC issuer and a reference to the variable containing the image set previously.

```shell
cosign sign --force -y --fulcio-url=https://$(oc get routes -n fulcio-system -o jsonpath='{.items[0].spec.host }') --rekor-url=https://$(oc get routes -n rekor-system -o jsonpath='{.items[0].spec.host }') --oidc-issuer=https://$(oc get routes -n keycloak-system -o jsonpath='{.items[0].spec.host }')/auth/realms/sigstore $IMAGE
```

A browser window will be launched to authenticate to Keycloak. As part of the setup, a single user called `sigstore` was created. Enter the following credentials:

Username: `sigstore`
Password: `redhat`

Once authenticated, a short lived certificate will be generated by Fulcio, a signature created against the image, the signature pushed to the registry, and a record placed in Rekor.

### Verifying the Image

Once an image has been signed, it can be verified in a number of forms.

First, use `cosign` to verify the image by executing the following command:

```shell
cosign verify --rekor-url=https://$(oc get routes -n rekor-system -o jsonpath='{.items[0].spec.host }') $IMAGE
```

`cosign` will then verify the signature with the record published in Rekor

Additional verification can be performed to confirmed that the OIDC details from Keycloak was also attached to the certificate:

```shell
skopeo inspect --raw --tls-verify=false docker://localhost:5000/sigstore/ubi8:sha256-397baf12363eb4fee845c94b0244e6b7d7341d13a8b59756fd5a738a3dce7343.sig | jq -r '.layers[0].annotations["dev.sigstore.cosign/certificate"]' | openssl x509 -noout -text
```

In the _X509v3_ extension properties, you should be able to located the URL of the Keycloak instance and the email from the Keycloak user:

```shell
            X509v3 Subject Alternative Name: critical
                email:sigstore@redhat.com
            1.3.6.1.4.1.57264.1.1: 
                https://keycloak-keycloak-system.apps.$BASEDOMAIN/auth/realms/sigstore
```

